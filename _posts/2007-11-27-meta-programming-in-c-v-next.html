---
layout: post
status: publish
published: true
title: Meta programming in C# v.next
author:
  display_name: bittercoder
  login: admin
  email: alex@devdefined.com
  url: http://blog.bittercoder.com/
author_login: admin
author_email: alex@devdefined.com
author_url: http://blog.bittercoder.com/
wordpress_id: 21
wordpress_url: http://blog.bittercoder.com/?p=21
date: '2007-11-27 20:01:50 +0000'
date_gmt: '2007-11-27 20:01:50 +0000'
categories:
- ".Net"
tags:
- Languages
comments: []
---
<p><img style="margin: 10px;" src="http://blog.bittercoder.com/images/stump.jpg" alt="stump" height="260" align="right" border="1" /></p>
<p>I've seen a few posts flying round between <a href="http://www.flanders.co.nz/blog/">Ivan</a> (<a href="http://www.flanders.co.nz/blog/archive/2007/11/27/mixins-in-c-3.0.aspx">1</a>,<a href="http://www.flanders.co.nz/blog/archive/2007/11/27/re-the-difference-between-meta-programming-and-il-weaving.aspx">2</a>)<br />
and <a href="http://www.ayende.com/Blog/">Ayende</a> (<a href="http://www.ayende.com/Blog/archive/2007/11/27/The-difference-between-meta-programming-and-IL-weaving.aspx">1</a>)&nbsp;re: meta programming in C# v.next and the implications of it being&nbsp;a statically typed / pre compiled language...</p>
<p>It's an interesting thought, but I can't help wondering if&nbsp;implementation of a rich meta-programming environment in C# -&nbsp;allowing changes at both a class and instance level at run-time -&nbsp;wouldn't go against the original spirit of the language itself, for&nbsp;me at least I'd be looking for a different language if I yearned&nbsp;for meta programming on a daily basis... one that was built from&nbsp;the ground up with my desires in mind.&nbsp; Take a moment to&nbsp;consider if C# had been built with meta-programming in mind from&nbsp;the outset, would we have bothered with declarative attributes?...&nbsp;ruby seems to get on fine without them (well at least until you try&nbsp;to integrate ruby with Java or .Net libraries)... and what about&nbsp;interfaces, what's the point of them?</p>
<p>Language spirit is an interesting thing - I don't think it's&nbsp;something intangible (this is science after all), but often it's&nbsp;something that's difficult to put into words, because it's a&nbsp;feeling coming up from a rapid and subconscious judgement call as&nbsp;you work with a language (ah la <a href="http://www.amazon.com/Blink-Power-Thinking-Without/dp/0316172324">Blink</a>)&nbsp;- it's also something that's difficult to appreciate until you&nbsp;start sitting down and thinking about writing a programming&nbsp;language of your own (what you haven't? For shame!)... and it&nbsp;builds an immediate appreciation for languages like C# and ruby and&nbsp;there founders - there are lot of difficult decisions, compromises&nbsp;and reasonable defaults that need to be decided on - and a massive&nbsp;amount of jiggling to make sure it all fits well together - so that&nbsp;you can finally identify the essence of the language - and worst of&nbsp;all you're not just having to satisfy your internal subconscious&nbsp;judgement calls, but a large audience in the development community,&nbsp;so that your language will be adopted by people because it feels&nbsp;"right" to them.</p>
<p>I still gravitate towards &nbsp;<a href="http://www.amazon.com/Programming-Language-Pragmatics-Second-Michael/dp/0126339511">programming language pragmatics</a> as a good book for examining&nbsp;the spirit of languages throughout the years and guises - it's&nbsp;definitely a book computer science student's should all be armed&nbsp;with on their first year, though I doubt many will be interested in&nbsp;the nuances of Fortran today.</p>
<p>Now, following up on that - I'd like to contrast meta programming&nbsp;with functional programming... are we in need of meta programming&nbsp;as we move towards a more functional approach by necessity (to&nbsp;reduce the overall complexity of software, and take better&nbsp;advantage of existing/emerging hardware by working at a higher&nbsp;level of abstraction, allowing for judgment to be made on our&nbsp;behalf i.e. about parallelization) and what makes more sense for a&nbsp;language like C#?</p>
<p>Personally I see C# moving more and more towards providing a&nbsp;pleasant bridge language between the imperative world and the&nbsp;purely functional word (weighed in favour of the imperative world,&nbsp;where as F# is weighed in favour of the functional world) ... and&nbsp;as such it makes more sense to me at least to draw inspiration from&nbsp;that domain, then dynamic languages and meta programming... just my&nbsp;opinion of course.</p>
<p>Given the time frames between C# versions - <a href="http://www.ironruby.net/">IronRuby</a> should be mature enough by&nbsp;the time c# v.net arrives that it should be a moot concern, and&nbsp;<a href="http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython">IronPython</a>&nbsp;is already pretty capable in the meta programming stakes as well,&nbsp;if you can hack the whitespace sensitivity.</p>
<p>Funnily enough (and this a bold claim I know :) - but I think the&nbsp;<a href="http://blogs.msdn.com/dsyme/archive/2007/04/07/draft-paper-on-f-active-patterns.aspx">pattern matching</a> support and associated features in <a href="http://research.microsoft.com/fsharp/fsharp.aspx">F#</a> would&nbsp;prove far more valuable tools for solving many of my day to day&nbsp;problems in C# than meta programming would be, when I take a&nbsp;subjective look at the code I write and the goals it's generally&nbsp;trying to achieve combined with the existing features and practices&nbsp;I've already embraced in C# (IoC/DI) it looks to "click" together&nbsp;in a much more cohesive manor.&nbsp;Thoughts?</p>
