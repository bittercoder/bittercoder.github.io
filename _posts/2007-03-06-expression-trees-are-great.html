---
layout: post
status: publish
published: true
title: Expression trees are great...
author:
  display_name: bittercoder
  login: admin
  email: alex@devdefined.com
  url: http://blog.bittercoder.com/
author_login: admin
author_email: alex@devdefined.com
author_url: http://blog.bittercoder.com/
wordpress_id: 83489697
wordpress_url: http://blog.bittercoder.com/?p=83489697
date: '2007-03-06 02:18:22 +0000'
date_gmt: '2007-03-06 02:18:22 +0000'
categories:
- ".Net"
tags: []
comments: []
---
<p>Have you ever wanted to be able to do something like this in<br />
C#?<br &#47;><br />
<br &#47;><br />
<b>string propertyName = GetName(MyClass.MyProperty);<&#47;b><br &#47;><br />
<br &#47;><br />
Well I have, in fact I've wanted the ability to do this since<br />
Version 1 of the .Net Framework, and now with C# 3.0 we finally<br />
can!<br &#47;><br />
<br &#47;><br />
First off, check out the original blog post here - <a href="http:&#47;&#47;themechanicalbride.blogspot.com&#47;2007&#47;03&#47;symbols-on-steroids-in-c.html"><br />
Symbols in C# 3.0<&#47;a> by <a href="http:&#47;&#47;themechanicalbride.blogspot.com&#47;">Jafar Husain<&#47;a> - it's a<br />
clever (and once I thought about, plainly obvious) use of extension<br />
methods and expression trees.<br &#47;><br />
<br &#47;></p>
<pre>
public static class SymbolExtensions<br />
{<br />
    public static string GetPropertySymbol<T,R>(this T obj, Expression<Func<T, R>> expr)<br />
    {<br />
        return ((System.Linq.Expressions.MemberExpression)           (((System.Linq.Expressions.LambdaExpression)(expr)).Body)).Member.Name;<br />
    }<br />
}<br />
<&#47;pre><br &#47;><br />
Usage requires a lambda, but that's not to painful, here's example<br />
usage:<br &#47;><br />
<br &#47;></p>
<pre>
MyClass o;<br />
&#47;&#47;...<br />
string propertyName = this.GetPropertySymbol(o => o.MyProperty)<br />
<&#47;pre><br &#47;><br />
The beauty of this is that refactoring is entirely painless, you<br />
don't need to spend time reviewing all the optional string<br />
replacements that resharper may have found in case you haven't<br />
mirrored a property or method name change correctly... it also<br />
looks like it could offer some nice usability improvements to some<br />
unit testing scenarios (nothing worse then unit tests that don't<br />
seamlessly refactor with your code).<br &#47;><br />
<br &#47;><br />
I wonder what other ideas are floating around for expression trees<br />
at the moment (outside of the obvious querying concepts) ?<br &#47;></p>
